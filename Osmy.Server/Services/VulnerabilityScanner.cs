using OSV.Client.Models;
using Osmy.Server.Data.Sbom;
using Osmy.Server.Data;
using Microsoft.EntityFrameworkCore;
using System.Text.Json;

namespace Osmy.Server.Services
{
    internal class VulnerabilityScanner : IDisposable
    {
        private readonly OSVClientEx _client = new();

        private readonly SoftwareDbContext _dbContext = new();

        public void Dispose()
        {
            _client.Dispose();
            _dbContext.Dispose();
        }

        public async Task ScanAsync(long sbomId, CancellationToken cancellationToken = default)
        {
            var executed = DateTime.Now;
            var sbom = await _dbContext.Sboms.Include(x => x.Packages)
                                             .ThenInclude(x => x.Vulnerabilities)
                                             .FirstOrDefaultAsync(x => x.Id == sbomId, cancellationToken)
                ?? throw new InvalidOperationException($"Sbom (Id={sbomId}) does not exists");
            await ScanPackageVulnerability(sbom.Packages.Where(x => x.IsDependentPackage), cancellationToken);

            // TODO SBOMの情報の更新
            sbom.LastVulnerabilityScan = executed;
            sbom.IsVulnerable = sbom.Packages.Any(x => x.Vulnerabilities.Any());
            await _dbContext.SaveChangesAsync(cancellationToken);
        }

        public async Task ScanAllAsync(CancellationToken cancellationToken = default)
        {
            var sboms = _dbContext.Sboms.Include(x => x.Packages)
                                        .ThenInclude(x => x.Vulnerabilities);
            var dependentPkgs = sboms.SelectMany(sbom => sbom.Packages.Where(x => x.IsDependentPackage))
                                     .ToArray();

            var executed = DateTime.Now;
            await ScanPackageVulnerability(dependentPkgs, cancellationToken);

            // TODO SBOMの情報の更新
            foreach (var sbom in sboms)
            {
                sbom.LastVulnerabilityScan = executed;
                sbom.IsVulnerable = sbom.Packages.Any(x => x.Vulnerabilities.Any());
            }
            await _dbContext.SaveChangesAsync(cancellationToken);
        }

        private Task ScanPackageVulnerability(IEnumerable<SbomPackageComponent> pkgs, CancellationToken cancellationToken)
        {
            return ScanPackageVulnerability(pkgs.ToArray(), cancellationToken);
        }

        private async Task ScanPackageVulnerability(SbomPackageComponent[] pkgs, CancellationToken cancellationToken)
        {
            // 名前とバージョンでパッケージをグループ化してクエリリストを作成
            var queryPkgPairs = pkgs.GroupBy(pkg => new QueryEx
            {
                Package = new QueryExPackage(pkg.Name, null),
                Version = pkg.Version,
            }).ToArray();

            // パッケージからクエリのインデックスを取得する辞書を作成
            var pkgQueryIndexDict = new Dictionary<SbomPackageComponent, int>();
            for (var pairIndex = 0; pairIndex < queryPkgPairs.Length; pairIndex++)
            {
                foreach (var pkg in queryPkgPairs[pairIndex])
                {
                    pkgQueryIndexDict.TryAdd(pkg, pairIndex);
                }
            }

            // クエリリストをチャンクに分割してOSV APIで問い合わせ
            var executed = DateTime.Now;
            const int ChunkSize = 1000;
            var chunkedResults = await Task.WhenAll(ExecuteBatchQueryAsync(queryPkgPairs.Select(x => x.Key), ChunkSize, cancellationToken));

            // TODO
            // 新しい/更新された脆弱性については脆弱性情報を取得してDBに保存
            // Sbom.Vulnerabilitiesを更新してDBに保存
            for (int i = 0; i < pkgs.Length; i++)
            {
                var pkg = pkgs[i];

                // クエリインデックスから，チャンク番号とチャンク内オフセットを計算して結果を取得
                int queryIndex = pkgQueryIndexDict[pkg];
                VulnerabilityList detectedVulns = chunkedResults[queryIndex / ChunkSize].Results[queryIndex % ChunkSize];
                if (detectedVulns.Vulnerabilities is null)
                {
                    continue;
                }
                foreach (var vuln in detectedVulns.Vulnerabilities)
                {
                    var vulnData = await _dbContext.Vulnerabilities.FirstOrDefaultAsync(x => x.Id == vuln.Id, cancellationToken);
                    if (vulnData is null)
                    {
                        // TODO 脆弱性情報を取得してDBに保存
                        var data = await _client.GetVulnerabilityById(vuln.Id, cancellationToken);
                        vulnData = new VulnerabilityData(data.Id, data.Modified, JsonSerializer.Serialize(data));
                        await _dbContext.Vulnerabilities.AddAsync(vulnData, cancellationToken);
                    }
                    else if (vuln.Modified > vulnData.Modified)
                    {
                        // TODO 更新された情報を取得してDBに反映
                        var data = await _client.GetVulnerabilityById(vuln.Id, cancellationToken);
                        vulnData.Modified = data.Modified;
                        vulnData.Data = JsonSerializer.Serialize(data);
                    }

                    // TOOD 多対多の関係がうまく保存されていない
                    if (!pkg.Vulnerabilities.Any(x => x.Id == vulnData.Id))
                    {
                        pkg.Vulnerabilities.Add(vulnData);
                    }

                    await _dbContext.SaveChangesAsync(cancellationToken);
                }
            }
        }

        private IEnumerable<Task<QueryChunk>> ExecuteBatchQueryAsync(IEnumerable<QueryEx> queries,
                                                                     int chunkSize,
                                                                     CancellationToken cancellationToken)
        {
            var chunks = queries.Chunk(chunkSize);
            return chunks.Select(queries =>
            {
                var batchQuery = new BatchQueryEx(queries);
                return _client.QueryAffectedBatchAsync(batchQuery, cancellationToken)
                              .ContinueWith(t => new QueryChunk(queries, t.Result.Results.ToArray()));
            });
        }

        private class QueryChunk
        {
            public QueryEx[] Queries { get; }
            public VulnerabilityList[] Results { get; }

            public QueryChunk(QueryEx[] queries, VulnerabilityList[] results)
            {
                Queries = queries;
                Results = results;
            }
        }
    }
}
