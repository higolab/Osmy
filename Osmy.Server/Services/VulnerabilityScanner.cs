using OSV.Client.Models;
using Osmy.Server.Data.Sbom;
using Osmy.Server.Data;
using Microsoft.EntityFrameworkCore;
using System.Text.Json;
using System.Data;
using OSV.Schema;

namespace Osmy.Server.Services
{
    internal class VulnerabilityScanner
    {
        /// <summary>
        /// Scan vulnerability of the software with the specified ID
        /// </summary>
        /// <param name="sbomId"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task ScanAsync(long sbomId, CancellationToken cancellationToken = default)
        {
            var executed = DateTime.Now;
            using (var dbContext = new SoftwareDbContext())
            {
                var targetPackages = await dbContext.Packages.Where(x => x.SbomId == sbomId && x.IsDependentPackage)
                                                             .ToArrayAsync(cancellationToken);
                await ScanPackagesAsync(targetPackages, cancellationToken);
            }

            await UpdateAfterScanAsync(sbomId, executed, cancellationToken);
        }

        public async Task ScanAllAsync(CancellationToken cancellationToken = default)
        {
            var executed = DateTime.Now;
            long[] sbomIds;
            using (var context = new SoftwareDbContext())
            {
                // TODO 必要な情報だけ取得，トランザクションの使用
                var dependentPkgs = await context.Packages.Where(x => x.IsDependentPackage)
                                                          .ToArrayAsync(cancellationToken);
                await ScanPackagesAsync(dependentPkgs, cancellationToken);

                // スキャンしたSBOMのIDリストを作成
                sbomIds = dependentPkgs.Select(x => x.SbomId)
                                       .Distinct()
                                       .ToArray();
            }

            // SBOMの情報の更新
            foreach (var sbomId in sbomIds)
            {
                await UpdateAfterScanAsync(sbomId, executed, cancellationToken);
            }
        }

        #region private
        private async Task ScanPackagesAsync(SbomPackageComponent[] pkgs, CancellationToken cancellationToken)
        {
            var result = await ExecuteQueryAsync(pkgs, cancellationToken);

            // 新しい/更新された脆弱性については脆弱性情報を取得してDBに保存
            foreach (var pkgId in pkgs.Select(pkg => pkg.Id))
            {
                var detectedVulns = result[pkgId];
                if (detectedVulns.Vulnerabilities is null)
                {
                    continue;
                }
                foreach (var vuln in detectedVulns.Vulnerabilities)
                {
                    var vulnData = await GetOrUpdateVulnerabilityAsync(vuln, cancellationToken);
                    await RelateVulnerabilityToPackageAsync(vulnData, pkgId, cancellationToken);
                }
            }
        }

        private async Task<VulnerabilityData> GetOrUpdateVulnerabilityAsync(Vulnerability vulnerability, CancellationToken cancellationToken)
        {
            VulnerabilityData? vulnData;
            using var context = new SoftwareDbContext();
            using var transaction = await context.Database.BeginTransactionAsync(IsolationLevel.Serializable, cancellationToken);

            vulnData = await context.Vulnerabilities.Include(x => x.Data)
                                                    .FirstOrDefaultAsync(x => x.Id == vulnerability.Id, cancellationToken);
            // 脆弱性情報を取得してDBに保存
            if (vulnData is null)
            {
                using var client = new OSVClientEx();
                var data = await client.GetVulnerabilityById(vulnerability.Id, cancellationToken);
                vulnData = new VulnerabilityData(data.Id, data.Modified, JsonSerializer.Serialize(data));
                context.Vulnerabilities.Add(vulnData);
            }
            // 更新された情報を取得してDBに反映
            else if (vulnerability.Modified > vulnData.Modified)
            {
                using var client = new OSVClientEx();
                var data = await client.GetVulnerabilityById(vulnerability.Id, cancellationToken);
                vulnData.Modified = data.Modified;
                vulnData.Data.Data = JsonSerializer.Serialize(data);
            }

            await context.SaveChangesAsync(cancellationToken);
            await transaction.CommitAsync(cancellationToken);
            return vulnData;
        }

        private static async Task RelateVulnerabilityToPackageAsync(VulnerabilityData vuln, long pkgId, CancellationToken cancellationToken)
        {
            // パッケージと脆弱性を紐づける
            using var context = new SoftwareDbContext();
            using (var transaction = await context.Database.BeginTransactionAsync(IsolationLevel.Serializable, cancellationToken))
            {
                var pkg = await context.Packages.Include(pkg => pkg.Vulnerabilities)
                                                  .FirstOrDefaultAsync(pkg => pkg.Id == pkgId, cancellationToken);
                if (pkg is not null)
                {
                    if (pkg.Vulnerabilities.All(x => x.Id != vuln.Id))
                    {
                        pkg.Vulnerabilities.Add(vuln);
                    }

                    await context.SaveChangesAsync(cancellationToken);
                    await transaction.CommitAsync(cancellationToken);
                }
            }
        }

        /// <summary>
        /// Update information of software (Last Scan Time & Flag whether it has vulnerabilities)
        /// </summary>
        /// <param name="sbomId"></param>
        /// <param name="executed"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        private static async Task UpdateAfterScanAsync(long sbomId, DateTime executed, CancellationToken cancellationToken)
        {
            using var context = new SoftwareDbContext();
            var sbom = await context.Sboms.Include(x => x.Packages)
                                          .ThenInclude(x => x.Vulnerabilities)
                                          .FirstOrDefaultAsync(x => x.Id == sbomId, cancellationToken);
            if (sbom is null)   // software was deleted during the scan
            {
                return;
            }

            sbom.LastVulnerabilityScan = executed;
            sbom.IsVulnerable = sbom.Packages.Any(x => x.Vulnerabilities.Count != 0);
            await context.SaveChangesAsync(cancellationToken);
        }

        private static async Task<QueryResult> ExecuteQueryAsync(SbomPackageComponent[] pkgs, CancellationToken cancellationToken)
        {
            // 名前とバージョンでパッケージをグループ化してクエリリストを作成
            var queryPkgPairs = pkgs.GroupBy(pkg => new QueryEx
            {
                Package = new QueryExPackage(pkg.Name, null),
                Version = pkg.Version,
            }).ToArray();

            // クエリリストをチャンクに分割してOSV APIで問い合わせ
            const int ChunkSize = 1000;
            var chunckedQueries = queryPkgPairs.Select(x => x.Key).Chunk(ChunkSize);
            var chunkedResults = await Task.WhenAll(chunckedQueries.Select(chunk => ExecuteBatchQueryAsync(chunk, cancellationToken)));

            return new QueryResult(queryPkgPairs, chunkedResults);

            static async Task<IEnumerable<VulnerabilityList>> ExecuteBatchQueryAsync(QueryEx[] queries, CancellationToken cancellationToken)
            {
                // MEMO:
                // if you reuse OSVClient (internally use RestSharp.RestClient),
                // something will go wrong and IOException will be thrown in the background.
                // 'Unable to read data from the transport connection: スレッドの終了またはアプリケーションの要求によって、I/O 処理は中止されました。.'
                // 内部例外 SocketException: スレッドの終了またはアプリケーションの要求によって、I/O 処理は中止されました。
                var batchQuery = new BatchQueryEx(queries);
                using var client = new OSVClientEx();
                var result = await client.QueryAffectedBatchAsync(batchQuery, cancellationToken);
                return result.Results;
            }
        }

        private class QueryResult
        {
            private readonly Dictionary<long, int> _pkgQueryIndexDict;
            private readonly VulnerabilityList[] _results;

            public QueryResult(IGrouping<QueryEx, SbomPackageComponent>[] queryPkgPairs, IEnumerable<IEnumerable<VulnerabilityList>> result)
            {
                // パッケージからクエリのインデックスを取得する辞書を作成
                _pkgQueryIndexDict = new Dictionary<long, int>(
                    queryPkgPairs.SelectMany((pkgs, queryIndex) => pkgs.Select(pkg => KeyValuePair.Create(pkg.Id, queryIndex)))
                );

                _results = result.SelectMany(x => x).ToArray();
            }

            public VulnerabilityList this[long pkgId]
            {
                get => _results[_pkgQueryIndexDict[pkgId]];
            }
        }

        private class QueryChunk(QueryEx[] queries, IEnumerable<VulnerabilityList> results)
        {
            public QueryEx[] Queries { get; } = queries;
            public IEnumerable<VulnerabilityList> Results { get; } = results;
        }
        #endregion
    }
}
