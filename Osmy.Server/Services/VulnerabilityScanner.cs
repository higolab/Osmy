using OSV.Client.Models;
using Osmy.Server.Data.Sbom;
using Osmy.Server.Data;
using Microsoft.EntityFrameworkCore;
using System.Text.Json;

namespace Osmy.Server.Services
{
    internal class VulnerabilityScanner : IDisposable
    {
        private static readonly SemaphoreSlim _dbUpdateSemaphore = new(1);

        private readonly OSVClientEx _client = new();

        private readonly SoftwareDbContext _dbContext = new();

        public void Dispose()
        {
            _client.Dispose();
            _dbContext.Dispose();
        }

        public async Task ScanAsync(long sbomId, CancellationToken cancellationToken = default)
        {
            var executed = DateTime.Now;
            var sbom = await _dbContext.Sboms.Include(x => x.Packages)
                                             .ThenInclude(x => x.Vulnerabilities)
                                             .FirstOrDefaultAsync(x => x.Id == sbomId, cancellationToken)
                ?? throw new InvalidOperationException($"Sbom (Id={sbomId}) does not exists");
            await ScanPackageVulnerability(sbom.Packages.Where(x => x.IsDependentPackage), cancellationToken);

            // TODO SBOMの情報の更新
            sbom.LastVulnerabilityScan = executed;
            sbom.IsVulnerable = sbom.Packages.Any(x => x.Vulnerabilities.Any());
            await _dbContext.SaveChangesAsync(cancellationToken);
        }

        public async Task ScanAllAsync(CancellationToken cancellationToken = default)
        {
            var dependentPkgs = await _dbContext.Packages.Where(x => x.IsDependentPackage)
                                                         .Include(x => x.Vulnerabilities)
                                                         .ToArrayAsync(cancellationToken);
            var sbomIds = dependentPkgs.Select(x => x.SbomId)
                                       .Distinct()
                                       .ToArray();
            var executed = DateTime.Now;
            await ScanPackageVulnerability(dependentPkgs, cancellationToken);

            // SBOMの情報の更新
            foreach (var sbomId in sbomIds)
            {
                try
                {
                    var sbom = await _dbContext.Sboms.Include(x => x.Packages)
                                                     .ThenInclude(x => x.Vulnerabilities)
                                                     .FirstAsync(x => x.Id == sbomId, cancellationToken);
                    sbom.LastVulnerabilityScan = executed;
                    sbom.IsVulnerable = sbom.Packages.Any(x => x.Vulnerabilities.Any());
                    await _dbContext.SaveChangesAsync(cancellationToken);
                }
                catch (DbUpdateException ex)
                {
                    foreach (var entry in ex.Entries)
                    {
                        await _dbContext.Entry(entry).ReloadAsync(cancellationToken);
                    }
                }
            }
        }

        private async Task ScanPackageVulnerability(IEnumerable<SbomPackageComponent> pkgs, CancellationToken cancellationToken)
        {
            await ScanPackageVulnerability(pkgs.ToArray(), cancellationToken);
        }

        private async Task ScanPackageVulnerability(SbomPackageComponent[] pkgs, CancellationToken cancellationToken)
        {
            // 名前とバージョンでパッケージをグループ化してクエリリストを作成)
            var queryPkgPairs = pkgs.GroupBy(pkg => new QueryEx
            {
                Package = new QueryExPackage(pkg.Name, null),
                Version = pkg.Version,
            }).ToArray();

            // パッケージからクエリのインデックスを取得する辞書を作成
            var pkgQueryIndexDict = new Dictionary<SbomPackageComponent, int>();
            for (var pairIndex = 0; pairIndex < queryPkgPairs.Length; pairIndex++)
            {
                foreach (var pkg in queryPkgPairs[pairIndex])
                {
                    pkgQueryIndexDict.TryAdd(pkg, pairIndex);
                }
            }

            // クエリリストをチャンクに分割してOSV APIで問い合わせ
            var executed = DateTime.Now;
            const int ChunkSize = 1000;
            var chunkedResults = await Task.WhenAll(ExecuteBatchQueryAsync(queryPkgPairs.Select(x => x.Key), ChunkSize, cancellationToken));
            
            // 新しい/更新された脆弱性については脆弱性情報を取得してDBに保存
            for (int i = 0; i < pkgs.Length; i++)
            {
                var pkg = pkgs[i];

                // クエリインデックスから，チャンク番号とチャンク内オフセットを計算して結果を取得
                //var queryIndex = queryPkgPairs.IndexOf(x => x.Contains(pkg)); MEMO:25%ぐらい遅くなる
                int queryIndex = pkgQueryIndexDict[pkg];
                VulnerabilityList detectedVulns = chunkedResults[queryIndex / ChunkSize].Results.ElementAt(queryIndex % ChunkSize);
                if (detectedVulns.Vulnerabilities is null)
                {
                    continue;
                }
                foreach (var vuln in detectedVulns.Vulnerabilities)
                {
                    try
                    {
                        await _dbUpdateSemaphore.WaitAsync(cancellationToken);
                        var vulnData = await _dbContext.Vulnerabilities.FirstOrDefaultAsync(x => x.Id == vuln.Id, cancellationToken);
                        if (vulnData is null)
                        {
                            // TODO 脆弱性情報を取得してDBに保存
                            var data = await _client.GetVulnerabilityById(vuln.Id, cancellationToken);
                            vulnData = new VulnerabilityData(data.Id, data.Modified, JsonSerializer.Serialize(data));
                            await _dbContext.Vulnerabilities.AddAsync(vulnData, cancellationToken);
                        }
                        else if (vuln.Modified > vulnData.Modified)
                        {
                            // TODO 更新された情報を取得してDBに反映
                            var data = await _client.GetVulnerabilityById(vuln.Id, cancellationToken);
                            vulnData.Modified = data.Modified;
                            vulnData.Data = new RawVulnerabilityData(JsonSerializer.Serialize(data));
                        }

                        // TOOD 多対多の関係がうまく保存されていない
                        if (!pkg.Vulnerabilities.Any(x => x.Id == vulnData.Id))
                        {
                            pkg.Vulnerabilities.Add(vulnData);
                        }

                        await _dbContext.SaveChangesAsync(cancellationToken);
                    }
                    finally
                    {
                        _dbUpdateSemaphore.Release();
                    }
                }
            }
        }

        private IEnumerable<Task<QueryChunk>> ExecuteBatchQueryAsync(IEnumerable<QueryEx> queries,
                                                                     int chunkSize,
                                                                     CancellationToken cancellationToken)
        {
            var chunks = queries.Chunk(chunkSize);
            return chunks.Select(queries =>
            {
                var batchQuery = new BatchQueryEx(queries);
                return _client.QueryAffectedBatchAsync(batchQuery, cancellationToken)
                              .ContinueWith(t => new QueryChunk(queries, t.Result.Results));
            });
        }

        private class QueryChunk
        {
            public QueryEx[] Queries { get; }
            public IEnumerable<VulnerabilityList> Results { get; }

            public QueryChunk(QueryEx[] queries, IEnumerable<VulnerabilityList> results)
            {
                Queries = queries;
                Results = results;
            }
        }
    }
}
