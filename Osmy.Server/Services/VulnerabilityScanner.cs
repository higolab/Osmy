using OSV.Client.Models;
using Osmy.Server.Data.Sbom;
using Osmy.Server.Data;
using Microsoft.EntityFrameworkCore;
using System.Text.Json;

namespace Osmy.Server.Services
{
    internal class VulnerabilityScanner : IDisposable
    {
        private static readonly SemaphoreSlim _dbUpdateSemaphore = new(1);

        private readonly OSVClientEx _client = new();

        private readonly SoftwareDbContext _dbContext = new();

        public void Dispose()
        {
            _client.Dispose();
            _dbContext.Dispose();
        }

        public async Task ScanAsync(long sbomId, CancellationToken cancellationToken = default)
        {
            var executed = DateTime.Now;
            var sbom = await _dbContext.Sboms.Include(x => x.Packages)
                                             .ThenInclude(x => x.Vulnerabilities)
                                             .FirstOrDefaultAsync(x => x.Id == sbomId, cancellationToken)
                ?? throw new InvalidOperationException($"Sbom (Id={sbomId}) does not exists");
            await ScanPackageVulnerability(sbom.Packages.Where(x => x.IsDependentPackage), cancellationToken);

            // SBOMの情報の更新
            sbom.LastVulnerabilityScan = executed;
            sbom.IsVulnerable = sbom.Packages.Any(x => x.Vulnerabilities.Count != 0);
            await _dbContext.SaveChangesAsync(cancellationToken);
        }

        public async Task ScanAllAsync(CancellationToken cancellationToken = default)
        {
            var dependentPkgs = await _dbContext.Packages.Where(x => x.IsDependentPackage)
                                                         .Include(x => x.Vulnerabilities)
                                                         .ToArrayAsync(cancellationToken);
            var sbomIds = dependentPkgs.Select(x => x.SbomId)
                                       .Distinct()
                                       .ToArray();
            var executed = DateTime.Now;
            await ScanPackageVulnerability(dependentPkgs, cancellationToken);

            // SBOMの情報の更新
            foreach (var sbomId in sbomIds)
            {
                try
                {
                    var sbom = await _dbContext.Sboms.Include(x => x.Packages)
                                                     .ThenInclude(x => x.Vulnerabilities)
                                                     .FirstAsync(x => x.Id == sbomId, cancellationToken);
                    sbom.LastVulnerabilityScan = executed;
                    sbom.IsVulnerable = sbom.Packages.Any(x => x.Vulnerabilities.Count != 0);
                    await _dbContext.SaveChangesAsync(cancellationToken);
                }
                catch (DbUpdateException ex)
                {
                    foreach (var entry in ex.Entries)
                    {
                        await _dbContext.Entry(entry).ReloadAsync(cancellationToken);
                    }
                }
            }
        }

        #region private
        private async Task ScanPackageVulnerability(IEnumerable<SbomPackageComponent> pkgs, CancellationToken cancellationToken)
        {
            await ScanPackageVulnerability(pkgs.ToArray(), cancellationToken);
        }

        private async Task ScanPackageVulnerability(SbomPackageComponent[] pkgs, CancellationToken cancellationToken)
        {
            // 名前とバージョンでパッケージをグループ化してクエリリストを作成)
            var queryPkgPairs = pkgs.GroupBy(pkg => new QueryEx
            {
                Package = new QueryExPackage(pkg.Name, null),
                Version = pkg.Version,
            }).ToArray();

            // パッケージからクエリのインデックスを取得する辞書を作成
            var pkgQueryIndexDict = new Dictionary<SbomPackageComponent, int>(
                queryPkgPairs.SelectMany((pkgs, queryIndex) => pkgs.Select(pkg => KeyValuePair.Create(pkg, queryIndex)))
            );

            // クエリリストをチャンクに分割してOSV APIで問い合わせ
            var executed = DateTime.Now;
            const int ChunkSize = 1000;
            var queries = queryPkgPairs.Select(x => x.Key);
            var chunkedResults = await Task.WhenAll(ExecuteBatchQueryAsync(queries, ChunkSize, cancellationToken));

            // 新しい/更新された脆弱性については脆弱性情報を取得してDBに保存
            foreach (var pkg in pkgs)
            {
                // クエリインデックスから，チャンク番号とチャンク内オフセットを計算して結果を取得
                //var queryIndex = queryPkgPairs.IndexOf(x => x.Contains(pkg)); MEMO:25%ぐらい遅くなる
                int queryIndex = pkgQueryIndexDict[pkg];
                VulnerabilityList detectedVulns = chunkedResults[queryIndex / ChunkSize].Results.ElementAt(queryIndex % ChunkSize);
                if (detectedVulns.Vulnerabilities is null)
                {
                    continue;
                }
                foreach (var vuln in detectedVulns.Vulnerabilities)
                {
                    try
                    {
                        // MEMO: ここから
                        await _dbUpdateSemaphore.WaitAsync(cancellationToken);
                        var vulnData = await _dbContext.Vulnerabilities.Include(x => x.Data).FirstOrDefaultAsync(x => x.Id == vuln.Id, cancellationToken);
                        if (vulnData is null)
                        {
                            // 脆弱性情報を取得してDBに保存
                            var data = await _client.GetVulnerabilityById(vuln.Id, cancellationToken);
                            vulnData = new VulnerabilityData(data.Id, data.Modified, JsonSerializer.Serialize(data));
                            _dbContext.Vulnerabilities.Add(vulnData);
                        }
                        else if (vuln.Modified > vulnData.Modified)
                        {
                            // 更新された情報を取得してDBに反映
                            var data = await _client.GetVulnerabilityById(vuln.Id, cancellationToken);
                            vulnData.Modified = data.Modified;
                            vulnData.Data.Data = JsonSerializer.Serialize(data);
                        }
                        // MEMO: ここまでと下は分離できる
                        // 脆弱性情報のIDが取れればOKなので，ロックを掛け続ける必要が無い

                        // パッケージと脆弱性を紐づける
                        if (pkg.Vulnerabilities.All(x => x.Id != vulnData.Id))
                        {
                            pkg.Vulnerabilities.Add(vulnData);
                        }

                        await _dbContext.SaveChangesAsync(cancellationToken);
                    }
                    finally
                    {
                        _dbUpdateSemaphore.Release();
                    }
                }
            }
        }

        private IEnumerable<Task<QueryChunk>> ExecuteBatchQueryAsync(IEnumerable<QueryEx> queries,
                                                                     int chunkSize,
                                                                     CancellationToken cancellationToken)
        {
            var chunks = queries.Chunk(chunkSize);
            return chunks.Select(queries =>
            {
                var batchQuery = new BatchQueryEx(queries);
                return _client.QueryAffectedBatchAsync(batchQuery, cancellationToken)
                              .ContinueWith(t => new QueryChunk(queries, t.Result.Results));
            });
        }

        private class QueryChunk(QueryEx[] queries, IEnumerable<VulnerabilityList> results)
        {
            public QueryEx[] Queries { get; } = queries;
            public IEnumerable<VulnerabilityList> Results { get; } = results;
        }
        #endregion
    }
}
