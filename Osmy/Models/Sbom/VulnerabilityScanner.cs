using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using QuickGraph;
using System.Threading;
using System.Linq;
using OSV.Client.Models;

namespace Osmy.Models.Sbom
{
    internal class VulnerabilityScanner : IDisposable
    {
        private readonly OSVClientEx _client = new();

        public void Dispose()
        {
            _client.Dispose();
        }

        public async Task<VulnerabilityScanResult> Scan(Sbom sbom, CancellationToken cancellationToken)
        {
            // MEMO: dfs.VisitedGraphはコンストラクタで渡したグラフのことで，実際に訪問した頂点と辺からなるグラフではない
            var dfs = new QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm<SbomPackage, IEdge<SbomPackage>>(sbom.DependencyGraph);
            var visited = new HashSet<SbomPackage>(sbom.RootPackages);
            dfs.TreeEdge += x => visited.Add(x.Target);
            foreach (SbomPackage package in sbom.RootPackages)
            {
                dfs.Compute(package);
            }

            var executed = DateTime.Now;
            var pkgScanResults = await ScanPackageVulnerability(visited, cancellationToken).ConfigureAwait(false);

            return new VulnerabilityScanResult(executed, sbom, pkgScanResults);
        }

        public async Task<IEnumerable<VulnerabilityScanResult>> Scan(IEnumerable<Sbom> sboms, CancellationToken cancellationToken)
        {
            var dependentPkgs = sboms.SelectMany(sbom =>
            {
                var visited = new List<SbomPackage>();
                var dfs = new QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm<SbomPackage, IEdge<SbomPackage>>(sbom.DependencyGraph);

                foreach (SbomPackage rootPkg in sbom.RootPackages)
                {
                    visited.Add(rootPkg);
                }

                dfs.TreeEdge += edge => visited.Add(edge.Target);
                foreach (SbomPackage pkg in sbom.RootPackages)
                {
                    dfs.Compute(pkg);
                }

                return visited;
            }).ToArray();

            var executed = DateTime.Now;
            var pkgScanResults = await ScanPackageVulnerability(dependentPkgs, cancellationToken).ConfigureAwait(false);

            return CreateResult();

            IEnumerable<VulnerabilityScanResult> CreateResult()
            {
                int index = 0;
                foreach (Sbom sbom in sboms)
                {
                    int nextIndex = index + sbom.Packages.Count;
                    yield return new VulnerabilityScanResult(executed, sbom, pkgScanResults[index..nextIndex]);
                    index = nextIndex;
                }
            }
        }

        private async Task<PackageScanResult> ScanPackageVulnerability(SbomPackage pkg, CancellationToken cancellationToken)
        {
            var query = new QueryEx
            {
                Package = new QueryExPackage
                {
                    Name = pkg.Name,
                },
                Version = pkg.Version,
            };

            var result = await _client.QueryAffectedAsync(query, cancellationToken).ConfigureAwait(false);

            return new PackageScanResult(pkg, result);
        }

        private Task<PackageScanResult[]> ScanPackageVulnerability(IEnumerable<SbomPackage> pkgs, CancellationToken cancellationToken)
        {
            return ScanPackageVulnerability(pkgs.ToArray(), cancellationToken);
        }

        private async Task<PackageScanResult[]> ScanPackageVulnerability(SbomPackage[] pkgs, CancellationToken cancellationToken)
        {
            // 名前とバージョンでパッケージをグループ化してクエリリストを作成
            var queryPkgPairs = pkgs.GroupBy(pkg => new QueryEx
            {
                Package = new QueryExPackage(pkg.Name, null),
                Version = pkg.Version,
            }).ToArray();

            // パッケージからクエリのインデックスを取得する辞書を作成
            var pkgQueryIndexDict = new Dictionary<SbomPackage, int>();
            for (var pairIndex = 0; pairIndex < queryPkgPairs.Length; pairIndex++)
            {
                foreach (var pkg in queryPkgPairs[pairIndex])
                {
                    pkgQueryIndexDict.TryAdd(pkg, pairIndex);
                }
            }

            // クエリリストをチャンクに分割してOSV APIで問い合わせ
            const int ChunkSize = 1000;
            var chunkedResults = await Task.WhenAll(queryPkgPairs.Select(x => x.Key).Chunk(ChunkSize).Select(queries =>
            {
                var batchQuery = new BatchQueryEx(queries);
                System.Diagnostics.Debug.WriteLine("ScanPackageVulnerability called!");
                return _client.QueryAffectedBatchAsync(batchQuery, cancellationToken).ContinueWith(t => new { Queries = queries, Results = t.Result.Results.ToArray() });
            })).ConfigureAwait(false);

            // パッケージスキャン結果を作成
            var pkgScanResults = new PackageScanResult[pkgs.Length];
            for (int i = 0; i < pkgScanResults.Length; i++)
            {
                SbomPackage pkg = pkgs[i];

                // クエリインデックスから，チャンク番号とチャンク内オフセットを計算して結果を取得
                int queryIndex = pkgQueryIndexDict[pkg];
                VulnerabilityList detectedVulns = chunkedResults[queryIndex / ChunkSize].Results[queryIndex % ChunkSize];
                pkgScanResults[i] = new PackageScanResult(pkg, detectedVulns);
            }

            return pkgScanResults;
        }
    }
}
