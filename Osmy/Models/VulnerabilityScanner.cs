using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using QuickGraph;
using Osmy.Models.Sbom;
using System.Threading;

namespace Osmy.Models
{
    internal class VulnerabilityScanner : IDisposable
    {
        private readonly OSVClientEx _client = new();

        public void Dispose()
        {
            _client.Dispose();
        }

        public async Task<VulnerabilityScanResult> Scan(Sbom.Sbom sbom, CancellationToken cancellationToken)
        {
            // MEMO: dfs.VisitedGraphはコンストラクタで渡したグラフのことで，実際に訪問した頂点と辺からなるグラフではない
            var dfs = new QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm<SbomPackage, IEdge<SbomPackage>>(sbom.DependencyGraph);
            var visited = new HashSet<SbomPackage>() { sbom.RootPackage };
            dfs.TreeEdge += x => visited.Add(x.Target);
            dfs.Compute(sbom.RootPackage);

            var scanResult = new VulnerabilityScanResult(sbom.Software);

            foreach (SbomPackage pkg in visited)
            {
                scanResult.Results.Add(await ScanPackageVulnerability(pkg, cancellationToken).ConfigureAwait(false));
            }

            return scanResult;
        }

        private async Task<PackageScanResult> ScanPackageVulnerability(SbomPackage pkg, CancellationToken cancellationToken)
        {
            var query = new QueryEx
            {
                Package = new QueryExPackage
                {
                    Name = pkg.Name,
                },
                Version = pkg.Version,
            };

            var result = await _client.QueryAffectedAsync(query, cancellationToken).ConfigureAwait(false);

            return new PackageScanResult(pkg, result);
        }
    }
}
