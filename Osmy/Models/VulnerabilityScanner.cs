using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using QuickGraph;
using Osmy.Models.Sbom;
using System.Threading;
using System.Linq;

namespace Osmy.Models
{
    internal class VulnerabilityScanner : IDisposable
    {
        private readonly OSVClientEx _client = new();

        public void Dispose()
        {
            _client.Dispose();
        }

        public async Task<VulnerabilityScanResult> Scan(Sbom.Sbom sbom, CancellationToken cancellationToken)
        {
            // MEMO: dfs.VisitedGraphはコンストラクタで渡したグラフのことで，実際に訪問した頂点と辺からなるグラフではない
            var dfs = new QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm<SbomPackage, IEdge<SbomPackage>>(sbom.DependencyGraph);
            var visited = new HashSet<SbomPackage>() { sbom.RootPackage };
            dfs.TreeEdge += x => visited.Add(x.Target);
            dfs.Compute(sbom.RootPackage);

            var executed = DateTime.Now;
            var pkgScanResults = await Task.WhenAll(visited.Select(pkg => ScanPackageVulnerability(pkg, cancellationToken))).ConfigureAwait(false);

            return new VulnerabilityScanResult(executed, sbom.Software, pkgScanResults);
        }

        private async Task<PackageScanResult> ScanPackageVulnerability(SbomPackage pkg, CancellationToken cancellationToken)
        {
            var query = new QueryEx
            {
                Package = new QueryExPackage
                {
                    Name = pkg.Name,
                },
                Version = pkg.Version,
            };

            var result = await _client.QueryAffectedAsync(query, cancellationToken).ConfigureAwait(false);

            return new PackageScanResult(pkg, result);
        }
    }
}
