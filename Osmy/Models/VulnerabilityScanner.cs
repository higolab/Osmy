using Osmy.Models.Sbom;
using OSV.Client.Models;
using OSV.Client;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using OSV.Schema;
using QuickGraph;

namespace Osmy.Models
{
    internal class VulnerabilityScanner : IDisposable
    {
        private readonly OSVClient _client = new();

        public void Dispose()
        {
            _client.Dispose();
        }

        public async Task<bool> Scan(ISbom sbom)
        {
            bool hasVulns = false;

            // TODO 依存関係グラフを辿って依存しているパッケージの脆弱性のみを検出する
            // MEMO: dfs.VisitedGraphはコンストラクタで渡したグラフのことで，実際に訪問した頂点と辺からなるグラフではない
            var dfs = new QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm<IPackage, IEdge<IPackage>>(sbom.DependencyGraph);
            var visited = new HashSet<IPackage>() { sbom.RootPackage };
            dfs.TreeEdge += x => visited.Add(x.Target);
            dfs.Compute(sbom.RootPackage);
            var notVisited = sbom.DependencyGraph.Vertices.Except(visited); // MEMO: fixedの方も標準ライブラリへの依存関係が抜けている

            foreach (IPackage pkg in visited)
            {
                hasVulns |= await IsPackageVulnerable(pkg);
            }

            return hasVulns;
        }

        private async Task<bool> IsPackageVulnerable(IPackage pkg)
        {
            var query = new Query
            {
                Package = new Package
                {
                    Name = pkg.Name,
                    //Ecosystem = Ecosystem.NuGet,    // TODO: 何も指定しないと自動的にGoに設定されてしまうので，Ecosystemにnullを設定できるように改変したものを使用
                },
                Version = pkg.Version,
            };

            var result = await _client.QueryAffectedAsync(query);

            return result.Vulnerabilities?.Any() ?? false;
        }
    }
}
