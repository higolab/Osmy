using ImTools;
using Osmy.Models;
using Osmy.Models.Sbom;
using Osmy.Properties;
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Osmy.Services
{
    internal class VulnerabilityScanService : QueueingBackgroundService<Sbom, VulnerabilityScanResult>
    {
        /// <summary>
        /// 脆弱性スキャナー
        /// </summary>
        private readonly VulnerabilityScanner _vulnerabilityScanner = new();

        /// <summary>
        /// 自動診断が必要なソフトウェアが存在するかをチェックする間隔
        /// </summary>
        public TimeSpan AutoScanCheckInterval { get; set; } = TimeSpan.FromMinutes(5);

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            var autoScanTask = Task.Run(() => StartAutoScanRequest(stoppingToken), stoppingToken);
            await Task.WhenAll(base.ExecuteAsync(stoppingToken), autoScanTask).ConfigureAwait(false);
        }

        protected override Task<VulnerabilityScanResult> ProcessAsync(Sbom sbom, CancellationToken cancellationToken)
        {
            return _vulnerabilityScanner.Scan(sbom, cancellationToken);
        }

        public override void Dispose()
        {
            _vulnerabilityScanner.Dispose();
            base.Dispose();
        }

        public Task<VulnerabilityScanResult> Scan(Sbom sbom, CancellationToken cancellationToken = default)
        {
            return EnqueueManual(sbom, cancellationToken);
        }

        private async Task StartAutoScanRequest(CancellationToken stoppingToken)
        {
            while (true)
            {
                using var context = new ManagedSoftwareContext();
                var before = DateTime.Now.Subtract(Settings.Default.VulnerabilityScanInterval);

                // 前回スキャンから一定期間経過しているソフトウェアのIDリストを作成
                var sbomIdsNotScannedRecently = context.Sboms
                    .Join(context.ScanResults,
                        sbom => sbom.Id,
                        scanResult => scanResult.SbomId,
                        (sbom, scanResult) => new { Sbom = sbom, ScanResult = scanResult })
                    .GroupBy(x => x.Sbom)
                    .Select(x => new { SbomId = x.Key.Id, Executed = x.Select(item => item.ScanResult).Max(item => item.Executed) })
                    .Where(x => x.Executed <= before)
                    .Select(x => x.SbomId)
                    .ToArray();

                // 一度もスキャンされていないソフトウェアのIDリストを作成
                var neverScannedSoftwares = context.Sboms
                    .Select(sbom => sbom.Id)
                    .Except(context.ScanResults.Select(x => x.SbomId).Distinct())
                    .ToArray();

                // スキャンが必要なソフトウェアのIDリストを作成
                var sbomIdsNeedScan = sbomIdsNotScannedRecently.Union(neverScannedSoftwares).ToArray();

                foreach (var sbomId in sbomIdsNeedScan)
                {
                    var sbom = context.Sboms.First(x => x.Id == sbomId);
                    var result = await EnqueueAuto(sbom, stoppingToken).ConfigureAwait(false);
                    context.ScanResults.Add(result);
                }

                await context.SaveChangesAsync(stoppingToken).ConfigureAwait(false);
                AppNotificationManager.NotifyVulnerability();

                await Task.Delay(AutoScanCheckInterval, stoppingToken).ConfigureAwait(false);
            }
        }
    }
}
