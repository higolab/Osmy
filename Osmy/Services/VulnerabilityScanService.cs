using ImTools;
using Microsoft.EntityFrameworkCore;
using Osmy.Models;
using Osmy.Models.Sbom;
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Osmy.Services
{
    internal class VulnerabilityScanService : BackgroundService
    {
        /// <summary>
        /// 自動診断が必要なソフトウェアが存在するかをチェックする間隔
        /// </summary>
        public TimeSpan AutoScanCheckInterval { get; set; } = TimeSpan.FromMinutes(5);

        /// <summary>
        /// 自動診断を行う間隔
        /// </summary>
        public TimeSpan AutoScanInterval { get; set; } = TimeSpan.FromDays(1);

        /// <summary>
        /// スキャンキュー
        /// </summary>
        private readonly ConcurrentQueue<ScanRequest> _scanQueue = new();

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            var scanTask = RunScanTask(stoppingToken);
            var autoScanTask = RunAutoRequestScanTask(stoppingToken);
            
            await Task.WhenAll(scanTask, autoScanTask).ConfigureAwait(false);
        }

        public async Task<VulnerabilityScanResult> Scan(Sbom sbom, CancellationToken cancellationToken)
        {
            var request = new ScanRequest(sbom, cancellationToken);
            cancellationToken.Register(() => request.TaskCompletionSource.TrySetCanceled());
            _scanQueue.Enqueue(request);

            return await request.TaskCompletionSource.Task.ConfigureAwait(false);
        }

        private async Task RunScanTask(CancellationToken stoppingToken)
        {
            using var scanner = new VulnerabilityScanner();
            while (true)
            {
                if (_scanQueue.TryDequeue(out ScanRequest? request))
                {
                    if (request.IsCancelled) { continue; }

                    var result = await scanner.Scan(request.Sbom, stoppingToken).ConfigureAwait(false);
                    request.TaskCompletionSource.TrySetResult(result);
                }

                await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken).ConfigureAwait(false);
            }
        }

        private async Task RunAutoRequestScanTask(CancellationToken stoppingToken)
        {
            while (true)
            {
                using var context = new ManagedSoftwareContext();
                var before = DateTime.Now.Subtract(AutoScanInterval);

                // 前回スキャンから一定期間経過しているソフトウェアのIDリストを作成
                var softwareIdsNotScannedRecently = context.Softwares
                    .Include(x => x.Sboms)
                    .Join(context.ScanResults,
                        software => software.Id,
                        scanResult => scanResult.SoftwareId,
                        (software, scanResult) => new { Software = software, ScanResult = scanResult })
                    .GroupBy(x => x.Software)
                    .Select(x => new { SoftwareId = x.Key.Id, Executed = x.Select(item => item.ScanResult).Max(item => item.Executed) })
                    .Where(x => x.Executed <= before)
                    .Select(x => x.SoftwareId)
                    .ToArray();

                // 一度もスキャンされていないソフトウェアのIDリストを作成
                var neverScannedSoftwares = context.Softwares
                    .Select(x => x.Id)
                    .Except(context.ScanResults.Select(x => x.SoftwareId).Distinct())
                    .ToArray();

                // スキャンが必要なソフトウェアのIDリストを作成
                var softwareIdsNeedScan = softwareIdsNotScannedRecently.Union(neverScannedSoftwares).ToArray();

                foreach (var softwareId in softwareIdsNeedScan)
                {
                    var software = context.Softwares.Include(x => x.Sboms).First(x => x.Id == softwareId);
                    var sbom = software.Sboms.First(x => x.IsUsing);

                    var result = await Scan(sbom, CancellationToken.None).ConfigureAwait(false);
                    context.ScanResults.Add(result);
                }

                await context.SaveChangesAsync(stoppingToken).ConfigureAwait(false);

                await Task.Delay(AutoScanCheckInterval, stoppingToken).ConfigureAwait(false);
            }
        }

        private class ScanRequest
        {
            public Sbom Sbom { get; }

            public TaskCompletionSource<VulnerabilityScanResult> TaskCompletionSource { get; }

            public bool IsCancelled => TaskCompletionSource.Task.IsCanceled;

            public CancellationToken CancellationToken { get; }

            public ScanRequest(Sbom sbom, CancellationToken cancellationToken)
            {
                Sbom = sbom;
                CancellationToken = cancellationToken;
                TaskCompletionSource = new TaskCompletionSource<VulnerabilityScanResult>();
            }
        }
    }
}
